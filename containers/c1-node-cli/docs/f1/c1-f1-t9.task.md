# Task 9 for Plan c1-node-cli-f1-project-structure

Establish logging infrastructure for the Node CLI tool.

**Layer**: application  
**Status**: prompted

### Reference

- [Feature Blueprint](/docs/f1-project-structure.blueprint.md)
- [Implementation Plan](/containers/c1-node-cli/docs/f1/f1-project-structure.plan.md)
- [TypeScript rules](/containers/c1-node-cli/.ai/rules/0-typescript.rules.md)  
- [Node CLI rules](/containers/c1-node-cli/.ai/rules/1-node-cli.rules.md)
- [Application Layer rules](/containers/c1-node-cli/.ai/rules/4-application-layer.rules.md)

## Instructions

### Create logging types

`/containers/c1-node-cli/src/application/logging/types.ts`:
- Create logging types:
  ```typescript
  export type LogLevel = 'error' | 'warn' | 'info' | 'debug';
  export type LogFormat = 'json' | 'simple';

  export interface LogMetadata {
    timestamp: string;
    level: LogLevel;
    message: string;
    [key: string]: unknown;
  }

  export interface LogConfig {
    level: LogLevel;
    format: LogFormat;
    file?: string;
  }
  ```

### Create logging formatters

`/containers/c1-node-cli/src/application/logging/formatters.ts`:
- Create LogFormatter class:
  ```typescript
  import { LogMetadata, LogFormat } from './types';
  import chalk from 'chalk';

  export class LogFormatter {
    public static format(metadata: LogMetadata, format: LogFormat): string {
      switch (format) {
        case 'json':
          return this.formatJson(metadata);
        case 'simple':
          return this.formatSimple(metadata);
        default:
          return this.formatSimple(metadata);
      }
    }

    private static formatJson(metadata: LogMetadata): string {
      return JSON.stringify(metadata);
    }

    private static formatSimple(metadata: LogMetadata): string {
      const timestamp = chalk.gray(`[${metadata.timestamp}]`);
      const level = this.getLevelColor(metadata.level)(metadata.level.toUpperCase());
      const message = chalk.white(metadata.message);
      const meta = this.formatMeta(metadata);

      return `${timestamp} ${level} ${message}${meta}`;
    }

    private static getLevelColor(level: string): (text: string) => string {
      switch (level) {
        case 'error':
          return chalk.red;
        case 'warn':
          return chalk.yellow;
        case 'info':
          return chalk.blue;
        case 'debug':
          return chalk.gray;
        default:
          return chalk.white;
      }
    }

    private static formatMeta(metadata: LogMetadata): string {
      const meta = { ...metadata };
      delete meta.timestamp;
      delete meta.level;
      delete meta.message;

      if (Object.keys(meta).length === 0) {
        return '';
      }

      return ` ${JSON.stringify(meta)}`;
    }
  }
  ```

### Create logging transports

`/containers/c1-node-cli/src/application/logging/transports.ts`:
- Create LogTransport class:
  ```typescript
  import { LogMetadata, LogConfig } from './types';
  import { FileUtils } from '../../domain/utils/file';
  import { ErrorFactory } from '../../domain/errors/factory';

  export abstract class LogTransport {
    public abstract write(metadata: LogMetadata): Promise<void>;
  }

  export class ConsoleTransport extends LogTransport {
    public async write(metadata: LogMetadata): Promise<void> {
      console.log(metadata.message);
    }
  }

  export class FileTransport extends LogTransport {
    private filePath: string;

    constructor(filePath: string) {
      super();
      this.filePath = filePath;
    }

    public async write(metadata: LogMetadata): Promise<void> {
      try {
        await FileUtils.appendFile(this.filePath, `${JSON.stringify(metadata)}\n`);
      } catch (error) {
        throw ErrorFactory.createValidationError('Failed to write log to file', {
          path: this.filePath,
          error
        });
      }
    }
  }
  ```

### Create logging manager

`/containers/c1-node-cli/src/application/logging/manager.ts`:
- Create LogManager class:
  ```typescript
  import { LogLevel, LogMetadata, LogConfig } from './types';
  import { LogFormatter } from './formatters';
  import { LogTransport, ConsoleTransport, FileTransport } from './transports';
  import { ConfigManager } from '../config/manager';

  export class LogManager {
    private static instance: LogManager;
    private transports: LogTransport[] = [];
    private config: LogConfig;

    private constructor() {
      this.config = ConfigManager.getInstance().getConfig().logging;
      this.initializeTransports();
    }

    public static getInstance(): LogManager {
      if (!LogManager.instance) {
        LogManager.instance = new LogManager();
      }
      return LogManager.instance;
    }

    public async log(level: LogLevel, message: string, meta?: Record<string, unknown>): Promise<void> {
      if (this.shouldLog(level)) {
        const metadata: LogMetadata = {
          timestamp: new Date().toISOString(),
          level,
          message,
          ...meta
        };

        for (const transport of this.transports) {
          await transport.write(metadata);
        }
      }
    }

    public async error(message: string, meta?: Record<string, unknown>): Promise<void> {
      await this.log('error', message, meta);
    }

    public async warn(message: string, meta?: Record<string, unknown>): Promise<void> {
      await this.log('warn', message, meta);
    }

    public async info(message: string, meta?: Record<string, unknown>): Promise<void> {
      await this.log('info', message, meta);
    }

    public async debug(message: string, meta?: Record<string, unknown>): Promise<void> {
      await this.log('debug', message, meta);
    }

    private shouldLog(level: LogLevel): boolean {
      const levels: LogLevel[] = ['error', 'warn', 'info', 'debug'];
      return levels.indexOf(level) <= levels.indexOf(this.config.level);
    }

    private initializeTransports(): void {
      // Always add console transport
      this.transports.push(new ConsoleTransport());

      // Add file transport if configured
      if (this.config.file) {
        this.transports.push(new FileTransport(this.config.file));
      }
    }
  }
  ```

### Create logging commands

`/containers/c1-node-cli/src/application/commands/log.ts`:
- Create LogCommands class:
  ```typescript
  import { program } from 'commander';
  import { CommandBase } from './base';
  import { LogManager } from '../logging/manager';
  import { LogLevel } from '../logging/types';

  export class LogCommands extends CommandBase {
    private logManager: LogManager;

    constructor(program: Command) {
      super(program);
      this.logManager = LogManager.getInstance();
    }

    public register(): void {
      this.program
        .command('log')
        .description('Manage logging')
        .addCommand(
          new Command('test')
            .description('Test logging levels')
            .action(() => this.execute(() => this.testLogging()))
        )
        .addCommand(
          new Command('set-level')
            .description('Set logging level')
            .requiredOption('-l, --level <level>', 'Logging level')
            .action((options) => this.execute(() => this.setLevel(options)))
        );
    }

    private async testLogging(): Promise<void> {
      await this.logManager.error('This is an error message');
      await this.logManager.warn('This is a warning message');
      await this.logManager.info('This is an info message');
      await this.logManager.debug('This is a debug message');
    }

    private async setLevel(options: { level: LogLevel }): Promise<void> {
      const configManager = ConfigManager.getInstance();
      const config = configManager.getConfig();
      config.logging.level = options.level;
      configManager.updateConfig(config);
      this.logInfo(`Logging level set to ${options.level}`);
    }
  }
  ```

> End of programming instructions for task `c1-f1-t9`. 