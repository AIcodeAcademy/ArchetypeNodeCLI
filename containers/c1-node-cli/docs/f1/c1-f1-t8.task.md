# Task 8 for Plan c1-node-cli-f1-project-structure

Implement configuration management structure for the Node CLI tool.

**Layer**: application  
**Status**: prompted

### Reference

- [Feature Blueprint](/docs/f1-project-structure.blueprint.md)
- [Implementation Plan](/containers/c1-node-cli/docs/f1/f1-project-structure.plan.md)
- [TypeScript rules](/containers/c1-node-cli/.ai/rules/0-typescript.rules.md)  
- [Node CLI rules](/containers/c1-node-cli/.ai/rules/1-node-cli.rules.md)
- [Application Layer rules](/containers/c1-node-cli/.ai/rules/4-application-layer.rules.md)

## Instructions

### Create configuration types

`/containers/c1-node-cli/src/application/config/types.ts`:
- Create configuration types:
  ```typescript
  export interface AppConfig {
    version: string;
    name: string;
    description: string;
    author: string;
    license: string;
    repository: string;
    bugs: string;
    homepage: string;
  }

  export interface LoggingConfig {
    level: 'error' | 'warn' | 'info' | 'debug';
    format: 'json' | 'simple';
    file?: string;
  }

  export interface CliConfig {
    commands: {
      container: boolean;
      feature: boolean;
      plan: boolean;
    };
    options: {
      verbose: boolean;
      debug: boolean;
      quiet: boolean;
    };
  }

  export interface Config {
    app: AppConfig;
    logging: LoggingConfig;
    cli: CliConfig;
  }
  ```

### Create configuration manager

`/containers/c1-node-cli/src/application/config/manager.ts`:
- Create ConfigManager class:
  ```typescript
  import { Config, AppConfig, LoggingConfig, CliConfig } from './types';
  import { FileUtils } from '../../domain/utils/file';
  import { PathUtils } from '../../domain/utils/path';
  import { ValidationUtils } from '../../domain/utils/validation';
  import { ErrorFactory } from '../../domain/errors/factory';

  export class ConfigManager {
    private static instance: ConfigManager;
    private config: Config;

    private constructor() {
      this.config = this.getDefaultConfig();
    }

    public static getInstance(): ConfigManager {
      if (!ConfigManager.instance) {
        ConfigManager.instance = new ConfigManager();
      }
      return ConfigManager.instance;
    }

    public async loadConfig(configPath?: string): Promise<void> {
      try {
        const path = configPath || this.getDefaultConfigPath();
        if (await FileUtils.exists(path)) {
          const content = await FileUtils.readFile(path);
          const loadedConfig = JSON.parse(content);
          this.config = this.mergeConfigs(this.config, loadedConfig);
        }
      } catch (error) {
        throw ErrorFactory.createValidationError('Failed to load configuration', {
          path: configPath,
          error
        });
      }
    }

    public async saveConfig(configPath?: string): Promise<void> {
      try {
        const path = configPath || this.getDefaultConfigPath();
        await FileUtils.writeFile(path, JSON.stringify(this.config, null, 2));
      } catch (error) {
        throw ErrorFactory.createValidationError('Failed to save configuration', {
          path: configPath,
          error
        });
      }
    }

    public getConfig(): Config {
      return { ...this.config };
    }

    public updateConfig(partialConfig: Partial<Config>): void {
      this.config = this.mergeConfigs(this.config, partialConfig);
    }

    private getDefaultConfig(): Config {
      return {
        app: {
          version: '1.0.0',
          name: 'archetype-node-cli',
          description: 'A CLI tool for managing archetypes',
          author: '',
          license: 'MIT',
          repository: '',
          bugs: '',
          homepage: ''
        },
        logging: {
          level: 'info',
          format: 'simple'
        },
        cli: {
          commands: {
            container: true,
            feature: true,
            plan: true
          },
          options: {
            verbose: false,
            debug: false,
            quiet: false
          }
        }
      };
    }

    private getDefaultConfigPath(): string {
      return PathUtils.join(process.cwd(), 'archetype.config.json');
    }

    private mergeConfigs(base: Config, override: Partial<Config>): Config {
      return {
        app: { ...base.app, ...override.app },
        logging: { ...base.logging, ...override.logging },
        cli: { ...base.cli, ...override.cli }
      };
    }
  }
  ```

### Create configuration loader

`/containers/c1-node-cli/src/application/config/loader.ts`:
- Create ConfigLoader class:
  ```typescript
  import { ConfigManager } from './manager';
  import { FileUtils } from '../../domain/utils/file';
  import { PathUtils } from '../../domain/utils/path';
  import { ErrorFactory } from '../../domain/errors/factory';

  export class ConfigLoader {
    private static instance: ConfigLoader;
    private configManager: ConfigManager;

    private constructor() {
      this.configManager = ConfigManager.getInstance();
    }

    public static getInstance(): ConfigLoader {
      if (!ConfigLoader.instance) {
        ConfigLoader.instance = new ConfigLoader();
      }
      return ConfigLoader.instance;
    }

    public async load(): Promise<void> {
      try {
        // Load global config
        const globalConfigPath = this.getGlobalConfigPath();
        if (await FileUtils.exists(globalConfigPath)) {
          await this.configManager.loadConfig(globalConfigPath);
        }

        // Load local config
        const localConfigPath = this.getLocalConfigPath();
        if (await FileUtils.exists(localConfigPath)) {
          await this.configManager.loadConfig(localConfigPath);
        }
      } catch (error) {
        throw ErrorFactory.createValidationError('Failed to load configuration', {
          error
        });
      }
    }

    private getGlobalConfigPath(): string {
      return PathUtils.join(
        process.env.HOME || process.env.USERPROFILE || '',
        '.archetype',
        'config.json'
      );
    }

    private getLocalConfigPath(): string {
      return PathUtils.join(process.cwd(), 'archetype.config.json');
    }
  }
  ```

### Create configuration commands

`/containers/c1-node-cli/src/application/commands/config.ts`:
- Create ConfigCommands class:
  ```typescript
  import { program } from 'commander';
  import { CommandBase } from './base';
  import { ConfigManager } from '../config/manager';
  import { ConfigLoader } from '../config/loader';

  export class ConfigCommands extends CommandBase {
    private configManager: ConfigManager;
    private configLoader: ConfigLoader;

    constructor(program: Command) {
      super(program);
      this.configManager = ConfigManager.getInstance();
      this.configLoader = ConfigLoader.getInstance();
    }

    public register(): void {
      this.program
        .command('config')
        .description('Manage configuration')
        .addCommand(
          new Command('show')
            .description('Show current configuration')
            .action(() => this.execute(() => this.showConfig()))
        )
        .addCommand(
          new Command('set')
            .description('Set configuration value')
            .requiredOption('-k, --key <key>', 'Configuration key')
            .requiredOption('-v, --value <value>', 'Configuration value')
            .action((options) => this.execute(() => this.setConfig(options)))
        )
        .addCommand(
          new Command('load')
            .description('Load configuration from file')
            .option('-f, --file <file>', 'Configuration file path')
            .action((options) => this.execute(() => this.loadConfig(options)))
        );
    }

    private async showConfig(): Promise<void> {
      const config = this.configManager.getConfig();
      this.logInfo('Current configuration:', { config });
    }

    private async setConfig(options: {
      key: string;
      value: string;
    }): Promise<void> {
      // Implementation
    }

    private async loadConfig(options: {
      file?: string;
    }): Promise<void> {
      if (options.file) {
        await this.configManager.loadConfig(options.file);
      } else {
        await this.configLoader.load();
      }
      this.logInfo('Configuration loaded successfully');
    }
  }
  ```

> End of programming instructions for task `c1-f1-t8`. 